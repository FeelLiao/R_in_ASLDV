[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R语言统计学习和数据可视化学习笔记",
    "section": "",
    "text": "欢迎",
    "crumbs": [
      "欢迎"
    ]
  },
  {
    "objectID": "top50ggplot2_visualizations.html",
    "href": "top50ggplot2_visualizations.html",
    "title": "10  Top 50 ggplot2 Visualizations",
    "section": "",
    "text": "10.1 Correlation\nThe following plots help to examine how well correlated two variables are.",
    "crumbs": [
      "ggplot2高级",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50ggplot2_visualizations.html#correlation",
    "href": "top50ggplot2_visualizations.html#correlation",
    "title": "10  Top 50 ggplot2 Visualizations",
    "section": "",
    "text": "10.1.1 Scatterplot\nThe most frequently used plot for data analysis is undoubtedly the scatterplot. Whenever you want to understand the nature of relationship between two variables, invariably the first choice is the scatterplot.\n\ntheme_set(theme_bw())\noptions(scipen = 999)\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(color = state, size = popdensity)) +\n  geom_smooth(method = \"loess\", se = FALSE) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) +\n  labs(\n    x = \"Area\",\n    y = \"Population\",\n    title = \"Scatterplot\",\n    subtitle = \"Area vs Population\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n\n\n10.1.2 Scatterplot With Encircling\nWhen presenting the results, sometimes I would encirlce certain special group of points or region in the chart so as to draw the attention to those peculiar cases. This can be conveniently done using the geom_encircle() in ggalt package.\n\nmidwest_select &lt;- midwest[\n  midwest$poptotal &gt; 350000 &\n    midwest$poptotal &lt;= 500000 &\n    midwest$area &gt; 0.01 &\n    midwest$area &lt; 0.1,\n]\n\n# Plot\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(col = state, size = popdensity)) + # draw points\n  geom_smooth(method = \"loess\", se = F) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) + # draw smoothing line\n  geom_encircle(aes(x = area, y = poptotal),\n    data = midwest_select,\n    color = \"red\",\n    size = 2,\n    expand = 0.08\n  ) + # encircle\n  labs(\n    subtitle = \"Area Vs Population\",\n    y = \"Population\",\n    x = \"Area\",\n    title = \"Scatterplot + Encircle\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n\n\n10.1.3 Counts Chart\nThe second option to overcome the problem of data points overlap is to use what is called a counts chart. Whereever there is more points overlap, the size of the circle gets bigger.\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_count(aes(colour = \"tomato3\"), show.legend = FALSE) +\n  labs(\n    subtitle = \"mpg: city vs highway mileage\",\n    y = \"hwy\",\n    x = \"cty\",\n    title = \"Counts Plot\"\n  )\n\n\n\n\n\n\n\n\n\n\n10.1.4 Bubble plot\nWhile scatterplot lets you compare the relationship between 2 continuous variables, bubble chart serves well if you want to understand relationship within the underlying groups based on:\nA Categorical variable (by changing the color) and Another continuous variable (by changing the size of points). In simpler words, bubble charts are more suitable if you have 4-Dimensional data where two of them are numeric (X and Y) and one other categorical (color) and another numeric variable (size).\nThe bubble chart clearly distinguishes the range of displ between the manufacturers and how the slope of lines-of-best-fit varies, providing a better visual comparison between the groups.\n\nmpg_select &lt;- mpg[mpg$manufacturer %in% c(\"audi\", \"ford\", \"honda\", \"hyundai\"), ]\nggplot(mpg_select, aes(displ, cty)) +\n  geom_jitter(aes(col = manufacturer, size = hwy)) +\n  geom_smooth(aes(col = manufacturer), method = \"lm\", se = FALSE) +\n  labs(\n    subtitle = \"mpg: Displacement vs City Mileage\",\n    title = \"Bubble chart\"\n  )\n\n\n\n\n\n\n\n\n\n\n10.1.5 Marginal Histogram / Boxplot\nIf you want to show the relationship as well as the distribution in the same chart, use the marginal histogram. It has a histogram of the X and Y variables at the margins of the scatterplot.\nThis can be implemented using the ggMarginal() function from the ggExtra package. Apart from a histogram, you could choose to draw a marginal boxplot or density plot by setting the respective type option.\n\n# mpg_select &lt;- mpg[mpg$hwy &gt;= 35 & mpg$cty &gt; 27, ]\ng &lt;- ggplot(mpg, aes(cty, hwy)) +\n  geom_count() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\nggMarginal(g, type = \"histogram\", fill = \"transparent\")",
    "crumbs": [
      "ggplot2高级",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50ggplot2_visualizations.html#deviation",
    "href": "top50ggplot2_visualizations.html#deviation",
    "title": "10  Top 50 ggplot2 Visualizations",
    "section": "10.2 Deviation",
    "text": "10.2 Deviation\nCompare variation in values between small number of items (or categories) with respect to a fixed reference.\n\n10.2.1 Diverging bars\nDiverging Bars is a bar chart that can handle both negative and positive values. This can be implemented by a smart tweak with geom_bar(). But the usage of geom_bar() can be quite confusing. Thats because, it can be used to make a bar chart as well as a histogram. Let me explain.\nBy default, geom_bar() has the stat set to count. That means, when you provide just a continuous X variable (and no Y variable), it tries to make a histogram out of the data.\nIn order to make a bar chart create bars instead of histogram, you need to do two things.\nSet stat=identity provide both x and y inside aes() where, x is either character or factor and y is numeric. In order to make sure you get diverging bars instead of just bars, make sure, your categorical variable has 2 categories that changes values at a certain threshold of the continuous variable. In below example, the mpg from mtcars dataset is normalised by computing the z score. Those vehicles with mpg above zero are marked green and those below are marked red.\n\nmtcars_new &lt;- mtcars |&gt;\n  mutate(\n    car_name = factor(rownames(mtcars)),\n    mpg_z = round((mpg - mean(mpg)) / sd(mpg), 2), # compute normalized mpg\n    mpg_type = ifelse(mpg_z &lt; 0, \"below\", \"above\")\n  ) |&gt; # above / below avg flag\n  arrange(mpg_z) |&gt;\n  as_tibble()\n# Diverging Barcharts\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_bar(stat = \"identity\", aes(fill = mpg_type), width = 0.5) +\n  scale_fill_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  labs(\n    subtitle = \"Normalised mileage from 'mtcars'\",\n    title = \"Diverging Bars\"\n  ) +\n  # using sorted car_name to adjust the rank of the x labels\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n10.2.2 Diverging Lollipop Chart\nLollipop chart conveys the same information as bar chart and diverging bar. Except that it looks more modern. Instead of geom_bar(), I use geom_point() and geom_segment() to get the lollipops right. Let’s draw a lollipop using the same data I prepared in the previous example of diverging bars.\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", fill = \"black\", size = 6) +\n  # geom_segment draw a line between\n  # (x,y) and (xend,yend)\n  geom_segment(aes(\n    y = 0, x = car_name,\n    yend = mpg_z, xend = car_name\n  ), color = \"black\") +\n  # label mpg_z -&gt; geom_text\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Lollipop Chart\",\n    subtitle = \"Normalized mileage from 'mtcars': Lollipop\"\n  ) +\n  ylim(-2.5, 2.5) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n10.2.3 Diverging Dot Plot\nDot plot conveys similar information. The principles are same as what we saw in Diverging bars, except that only point are used. Below example uses the same data prepared in the diverging bars example.\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", aes(color = mpg_type), size = 6) +\n  scale_color_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Dot Plot\",\n    subtitle = \"Normalized mileage from 'mtcars': Dot plot\"\n  ) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()",
    "crumbs": [
      "ggplot2高级",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50ggplot2_visualizations.html#ranking",
    "href": "top50ggplot2_visualizations.html#ranking",
    "title": "10  Top 50 ggplot2 Visualizations",
    "section": "10.3 Ranking",
    "text": "10.3 Ranking\nUsed to compare the position or performance of multiple items with respect to each other. Actual values matters somewhat less than the ranking.\n\n10.3.1 Dot Plot\nDot plots are very similar to lollipops, but without the line and is flipped to horizontal position. It emphasizes more on the rank ordering of items with respect to actual values and how far apart are the entities with respect to each other.\n\n# Prepare data: group mean city mileage by manufacturer.\ncty_mpg &lt;- mpg |&gt;\n  group_by(manufacturer) |&gt;\n  summarise(mileage = mean(cty, na.rm = TRUE)) |&gt;\n  rename(make = manufacturer) |&gt;\n  mutate(make = factor(make, levels = make)) |&gt;\n  arrange(mileage)\n\nggplot(cty_mpg, aes(x = make, y = mileage)) +\n  geom_point(color = \"tomato2\", size = 3) +\n  geom_segment(\n    aes(\n      x = make, y = min(mileage),\n      xend = make, yend = max(mileage)\n    ),\n    linetype = \"dashed\", linewidth = 0.1\n  ) +\n  labs(\n    title = \"Dot Plot\",\n    subtitle = \"Make Vs Avg. Mileage\",\n    caption = \"source: mpg\"\n  ) +\n  scale_x_discrete(limits = cty_mpg$make) +\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n10.3.2 Slope Chart\nSlope charts are an excellent way of comparing the positional placements between 2 points on time. At the moment, there is no builtin function to construct this. Following code serves as a pointer about how you may approach this.\n\n# Prepare data\ndf &lt;- read_csv(\"https://raw.githubusercontent.com/selva86/datasets/master/gdppercap.csv\")\n\nleft_label &lt;- paste(df$continent, round(df$`1952`), sep = \",\")\nright_label &lt;- paste(df$continent, round(df$`1957`), sep = \",\")\ndf$class &lt;- ifelse(df$`1957` - df$`1952` &lt; 0, \"red\", \"green\")\n\n# Plot\nggplot(df) +\n  geom_segment(aes(x = 1, y = `1952`, xend = 2, yend = `1957`, color = class),\n    linewidth = 0.75, show.legend = FALSE\n  ) +\n  geom_vline(xintercept = 1, linetype = \"dashed\", linewidth = 0.1) +\n  geom_vline(xintercept = 2, linetype = \"dashed\", linewidth = 0.1) +\n  scale_color_manual(\n    labels = c(\"Up\", \"Down\"),\n    values = c(\"green\" = \"#00ba38\", \"red\" = \"#f8766d\")\n  ) +\n  labs(x = \"\", y = \"Mean GdpPerCap\") +\n  xlim(0.5, 2.5) +\n  ylim(0, (1.1 * max(df$`1957`, df$`1952`))) +\n  geom_text(\n    label = left_label, y = df$`1952`,\n    x = rep(1, nrow(df)), hjust = 1.1, size = 3.5\n  ) +\n  geom_text(\n    label = right_label, y = df$`1957`,\n    x = rep(2, nrow(df)), hjust = -0.1, size = 3.5\n  ) +\n  geom_text(\n    label = \"Time 1\", x = 1,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = 1.2, size = 5\n  ) +\n  geom_text(\n    label = \"Time 2\", x = 2,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = -0.2, size = 5\n  ) +\n  theme_classic() +\n  theme(\n    panel.background = element_blank(),\n    panel.grid = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.x = element_blank(),\n    panel.border = element_blank(),\n    plot.margin = unit(c(1, 2, 1, 2), \"cm\")\n  )\n\n\n\n\n\n\n\n\n\n\n10.3.3 Dumbbell Plot\nDumbbell charts are a great tool if you wish to: 1. Visualize relative positions (like growth and decline) between two points in time. 2. Compare distance between two categories.\nIn order to get the correct ordering of the dumbbells, the Y variable should be a factor and the levels of the factor variable should be in the same order as it should appear in the plot.\n\n# Prepare data\nhealth &lt;- read.csv(\"https://raw.githubusercontent.com/selva86/datasets/master/health.csv\")\n\nhealth$Area &lt;- factor(health$Area,\n  levels = as.character(health$Area)\n)\n\n# Plot\nggplot(health, aes(x = pct_2013, xend = pct_2014, y = Area, group = Area)) +\n  geom_dumbbell(\n    color = \"#a3c4dc\", size = 0.75,\n    colour_x = \"#0e668b\"\n  ) +\n  scale_x_continuous(labels = scales::percent) +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Dumbbell Chart\",\n    subtitle = \"Pct Change: 2013 vs 2014\",\n    caption = \"Source: https://github.com/hrbrmstr/ggalt\"\n  ) +\n  theme_classic() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),\n    plot.background = element_rect(fill = \"#f7f7f7\"),\n    panel.background = element_rect(fill = \"#f7f7f7\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"grey50\"),\n    axis.ticks = element_blank(),\n    legend.position = \"top\",\n    panel.border = element_blank()\n  )",
    "crumbs": [
      "ggplot2高级",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50ggplot2_visualizations.html#distribution",
    "href": "top50ggplot2_visualizations.html#distribution",
    "title": "10  Top 50 ggplot2 Visualizations",
    "section": "10.4 Distribution",
    "text": "10.4 Distribution\nWhen you have lots and lots of data points and want to study where and how the data points are distributed.\n\n10.4.1 Tufte Boxplot\nTufte box plot, provided by ggthemes package is inspired by the works of Edward Tufte. Tufte’s Box plot is just a box plot made minimal and visually appealing.\n\nggplot(mpg, aes(manufacturer, cty)) +\n  geom_tufteboxplot() +\n  theme_tufte() + # from ggthemes\n  theme(axis.text.x = element_text(angle = 65, vjust = 0.6)) +\n  labs(\n    title = \"Tufte Styled Boxplot\",\n    subtitle = \"City Mileage grouped by Class of vehicle\",\n    caption = \"Source: mpg\",\n    x = \"Class of Vehicle\",\n    y = \"City Mileage\"\n  )\n\n\n\n\n\n\n\n\n\n\n10.4.2 Population Pyramid\nPopulation pyramids offer a unique way of visualizing how much population or what percentage of population fall under a certain category. The below pyramid is an excellent example of how many users are retained at each stage of a email marketing campaign funnel.\n\noptions(scipen = 999)\n\nemail_campaign_funnel &lt;- read.csv(\"https://raw.githubusercontent.com/selva86/datasets/master/email_campaign_funnel.csv\")\n\n# X Axis Breaks and Labels\nbrks &lt;- seq(-15000000, 15000000, 5000000)\nlbls &lt;- paste0(as.character(c(seq(15, 0, -5), seq(5, 15, 5))), \"m\")\n\nggplot(\n  email_campaign_funnel,\n  aes(x = Stage, y = Users, fill = Gender)\n) + # Fill column\n  geom_bar(stat = \"identity\", width = 0.6) + # draw the bars\n  scale_y_continuous(\n    breaks = brks, # Breaks\n    labels = lbls\n  ) + # Labels\n  coord_flip() + # Flip axes\n  labs(title = \"Email Campaign Funnel\") +\n  theme_tufte() + # Tufte theme from ggfortify\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    axis.ticks = element_blank()\n  ) + # Centre plot title\n  scale_fill_brewer(palette = \"Dark2\") # Color palette",
    "crumbs": [
      "ggplot2高级",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50ggplot2_visualizations.html#composition",
    "href": "top50ggplot2_visualizations.html#composition",
    "title": "10  Top 50 ggplot2 Visualizations",
    "section": "10.5 Composition",
    "text": "10.5 Composition\n\n10.5.1 Waffle Chart\nWaffle charts is a nice way of showing the categorical composition of the total population. Though there is no direct function, it can be articulated by smartly maneuvering the ggplot2 using geom_tile() function. The below template should help you create your own waffle.\n\nvar &lt;- mpg$class\ndf &lt;- expand.grid(y = 1:10, x = 1:10)\ncateg_table &lt;- round(table(var) * ((10 * 10) / (length(var))))\ndf$category &lt;- factor(rep(names(categ_table), categ_table))\n\nggplot(df, aes(x = x, y = y, fill = category)) +\n  geom_tile(color = \"black\", linewidth = 0.5) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0), trans = \"reverse\") +\n  scale_fill_brewer(palette = \"Set2\") +\n  labs(\n    title = \"Waffle Chart\", subtitle = \"'Class' of vehicles\",\n    caption = \"Source: mpg\"\n  ) +\n  theme(\n    plot.title = element_text(size = rel(1.2)),\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    axis.ticks = element_blank(),\n    legend.title = element_blank(),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\n\n\n10.5.2 Treemap\nTreemap is a nice way of displaying hierarchical data by using nested rectangles. The treemapify package provides the necessary functions to convert the data in desired format (treemapify) as well as draw the actual plot (ggplotify).\nIn order to create a treemap, the data must be converted to desired format using treemapify(). The important requirement is, your data must have one variable each that describes the area of the tiles, variable for fill color, variable that has the tile’s label and finally the parent group.\nOnce the data formatting is done, just call ggplotify() on the treemapified data.\n\nproglangs &lt;- read.csv(\"https://raw.githubusercontent.com/selva86/datasets/master/proglanguages.csv\")\n\nggplot(proglangs, aes(\n  area = value,\n  fill = parent, group = parent, label = id\n)) +\n  geom_treemap() +\n  geom_treemap_text(\n    fontface = \"italic\", colour = \"white\", place = \"centre\",\n    grow = TRUE\n  ) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  scale_fill_brewer(palette = \"Dark2\")",
    "crumbs": [
      "ggplot2高级",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50ggplot2_visualizations.html#groups",
    "href": "top50ggplot2_visualizations.html#groups",
    "title": "10  Top 50 ggplot2 Visualizations",
    "section": "10.6 Groups",
    "text": "10.6 Groups\n\n10.6.1 Hierarchical Dendrogram\n\ntheme_set(theme_bw())\n\nhc &lt;- hclust(dist(USArrests), \"ave\")  # hierarchical clustering\n\n# plot\nggdendrogram(hc, rotate = TRUE, size = 2)\n\n\n\n\n\n\n\n\n\n\n10.6.2 Clusters\nIt is possible to show the distinct clusters or groups using geom_encircle(). If the dataset has multiple weak features, you can compute the principal components and draw a scatterplot using PC1 and PC2 as X and Y axis.\n\ntheme_set(theme_classic())\n\n# Compute data with principal components ------------------\ndf &lt;- iris[c(1, 2, 3, 4)]\npca_mod &lt;- prcomp(df) # compute principal components\n\n# Data frame of principal components ----------------------\ndf_pc &lt;- data.frame(pca_mod$x,\n  Species = iris$Species\n) # dataframe of principal components\ndf_pc_vir &lt;- df_pc[df_pc$Species == \"virginica\", ] # df for 'virginica'\ndf_pc_set &lt;- df_pc[df_pc$Species == \"setosa\", ] # df for 'setosa'\ndf_pc_ver &lt;- df_pc[df_pc$Species == \"versicolor\", ] # df for 'versicolor'\n\n# Plot ----------------------------------------------------\nggplot(df_pc, aes(PC1, PC2, col = Species)) +\n  geom_point(aes(shape = Species), size = 2) + # draw points\n  labs(\n    title = \"Iris Clustering\",\n    subtitle = \"With principal components PC1 and PC2 as X and Y axis\",\n    caption = \"Source: Iris\"\n  ) +\n  coord_cartesian(\n    xlim = 1.2 * c(min(df_pc$PC1), max(df_pc$PC1)),\n    ylim = 1.2 * c(min(df_pc$PC2), max(df_pc$PC2))\n  ) + # change axis limits\n  geom_encircle(data = df_pc_vir, aes(x = PC1, y = PC2)) + # draw circles\n  geom_encircle(data = df_pc_set, aes(x = PC1, y = PC2)) +\n  geom_encircle(data = df_pc_ver, aes(x = PC1, y = PC2))",
    "crumbs": [
      "ggplot2高级",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  }
]